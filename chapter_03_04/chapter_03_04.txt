1. 계층으로 구성
웹 계층, 도메인 계층, 영속성 계층으로 패키지를 나눔.
계층형 구조의 단점
1) 애플리케이션의 기능 조각이나 특성을 구분 짓는 패키지 경계가 없다.
  다른 기능을 추가해야할 경우 web 패키지에 컨트롤러 추가, domain 패키지에 관련 서비스 추가, persistance 패키지에 레포지토리를 추가하게 됨.
   서로 연관되지 않은 기능들을 같은 패키지에 넣게됨으로써 예상치 못한 부수효과를 일으킬 수 있음
2) 애플리케이션이 어떤 유스케이스들을 제공하는지 파악할 수 없다.
   계층형 구조를 패키지로 사용했기 때문에 클래스명만으로는 이 클래스가 어떤 기능(유스케이스)를 구현했는지 한눈에 파악하기 어려움
3) 어떤 기능이 웹 어댑터에서 호출되는지, 영속성 어댑터가 도메인 계층에 어떤 기능을 제공하는지 한눈에 알아볼 수 없음. 
   인커밍 포트와 아웃고잉 포트가 코드내부에 숨겨져 있음

2. 기능으로 구성
기능을 중심으로 최상위 패키지 아래에 모두 구성
각 기능을 묶은 새로운 그룹은 같은 레벨의 새로운 패키지로 들어가고, 패키지 외부에서 접근을 제한하려할 경우 package-private 접근 수준을 이용해 패키지간의 경계를 강화할 수 있다.
***package-private 접근 수준 이란? 멤버가 소속된 패키지 안의 클래스에서만 접근할 수있음. Java에서는 접근 제한자를 명시하지 않을 경우 적용됨
추가로 서비스의 책임을 좁혀 하나의 유스케이스를 구현한 코드를 클래스명으로 찾을 수 있도록함
기능중심 구성의 단점
1) 아키텍처의 가시성이 훨씬 떨어진다. 어댑터를 나타내는 패키지명이 없고, 인커밍 포트, 아웃고잉 포트도 확인할 수 없다. 
 
3. 아키텍처적으로 표현력 있는 패키지 구조
최상위에는 특정 유스케이스를 구현한 모듈임을 나타내는 패키지로 묶음
1) 도메인 모델이 속한 domain 패키지
2) 도메인 모델을 둘러싼 서비스 계층을 포함하고 인커밍 포트와 아웃고잉 포트 인터페이스를 하위로 가진 application 패키지
3) 애플리케이션 계층의 인커밍 포트를 호출하는 인커밍 어댑터와 아웃고잉 포트에 대한 구현을 제공하는 아웃고잉 어댑터를 포함한 adapter 패키지



***풍부한 도메인 모델
클래스안에 다양한 도메인 로직을 구현해둠(책에서 예시 Account)
***빈약한 도메인 모델
클래스안에 대부분의 로직 없이 단순한 데이터 구조로만 구성(getter, setter 정도만)

유스케이스마다 다른 출력 모델
출력은 호출자에게 꼭 필요한 데이터만 들고 있어야 하지만 가능한 구체적일 수록 좋다. 유스케이스들 간에 같은 출력 모델을 공유하게 되면 유스케이스들도 강하게 결합된다. 단일 책임 원칙을 적용하고 모델을 분리해서 유지하는 것이 유스케이스의 결합을 제거하는데 도움이 된다.

단순 읽기만 하는 경우는 유스케이스와 구분되는 쿼리서비스(query service)로 구현함


https://lucas-owner.tistory.com/19